---
layout: default
title:  "JavaScript: фрактал отсоса"
date:   2018-05-02 00:00:00
categories: main
---

# JavaScript: фрактал отсоса

Почитывая в майские Хабр, наткнулся на статью под названием [Javascript: фрактал отсоса][js-fractal], и меня понесло. Так как я являюсь ярым ненавистником JS'а и всего, что от него произошло, то, решив стать археологом, поднимаю эту тему снова.

> На заметочку: статья написана четыре с лишним года тому назад 

## Предсказания
### Проблемы языка

Недолго думая: более чем соглашусь с автором
Что забавно, так это то, что его "предсказания" сбываются - `npm` уподобился огромной помойке, проблемы языка начинают решаться очень несвоевременно(те же `ES6` классы появились лишь спустя 15 месяцев спустя выхода статьи), а если же и решаются, то на таком качестве, что плакать хочется, и вот два тому примера:

1. Создаю класс с приватным полем `_active`, "унаследовавшись" от другого класса. Отгребаю по полной, потому что поле `_active` есть у родителя. Логика? Какая логика?
- 1+. Приватным для разработчика поле стало в результате добавления подчерка спереди имени поля...
- 1++. Возможно даже от добавления `/** @private */` строчкой выше, но это скорее для компилятора
- 1+++. Как жаль, что оно всё ещё `protected`. "`protected`". "Инновации!", - как сказали бы в Apple. Designed by prototype.
2. Регулярные выражения. Не знаю как вы, но у меня частенько возникает необходимость просмотра вперёд-назад. Казалось бы - всё просто и легко. Нет. Просмотра назад нет. Не завезли. В целом ОК - уже свыкся, что инструментов не море, но пруд, а нужных нет, - реверсим строку и...подождите-ка, а разве автор хабростатьи не говорил про гордость от странных конструкций? Падажиёбана!

Многие годы я не залазил в JS, не прикасался к нему в опаске подхватить какую-то заразу и...и теперь я вполне себе оперирую такими бесполезными для себя знаниями как то, что `+[![]]` есть `NaN`. Было то время, когда глядя на регулярное выражение я думал о том, каким же человеком нужно быть, чтобы такое написать и считать, что это круто, - это ж магия, которую никто никогда не поправит. И вот я пишу регулярки на работе и соревнуюсь по разного рода извращённым регуляркам с коллегами. Оправдаюсь тем, что в правильных руках инструмент мощный(разумеется, я про регулярки).

### Пристройки сбоку
Как так? Проблемы у него, посмотри на `%FRAMEWORK_NAME%` - там уже всё сделали за тебя!

Сравнивал, сравниваю и буду сравнивать JS с девушкой, с которой просыпается абстрактный разработчик после возвращения из клуба(смешно, да? _Нет_). В клубе он познакомился с доступной красавицей, а на утро весь её макияж(библиотеки и фреймворки) на подушке, бельё - с пушапом(Closure Compiler), а зовут её JavaScript, хотя представилась принцессой Java.

Абсолютно полностью согласен с `@PerlPower`(автор хабростатьи) - библиотеки не должны править язык, закрывать его косяки(тем более создавая новые), они должны лишь расширять его, как Boost для C++. А не "у нас тут свой Array. Он как обычный, только push возвращает undefined, а не length". Не удивлюсь, если там через `prototype` присунули `void` и на этом всё закончилось. Пример притянут за уши, но рассказывать про исключение, возникающее при `new URL("foo.bar")`, уж очень не хочется.

Окей, даже допустим, что большое количество библиотек и фреймворков - показатель совершенства языка. Только вот каким можно доверять, а каким нет? От каких завтра откажутся, назовут устаревшими и бросят, а каким ещё жить годик-другой? В Python число модулей зашкаливает, но почему-то питонисты не ноют о том, что у них что-то потеряло поддержку разработчиков, - всё у них в этом смысле неплохо. Не смогу назвать ни одного питониста, который бы для вывода графиков использовал бы что-то кроме `matplotlib`. Джаваскриптизёры, ваш выход. Я не знаю ни одной, поэтому прогуглил - один из первых результатов - "9 библиотек на Javascript для построения интерактивных графиков и диаграмм"(и в комментах там ещё одну либу предложили). Отсутствие хоть какого-либо стандарта или эталона-любимчика есть зло.

К слову, в Python есть стандартная библиотека, да.

### Кладезь _сомнительных_ "знаний"
Сомнительными знаниями я обзову всё в JS, что противоречит интуиции и вынуждает зазубривать.
Чем что-то описывать, я лучше сошлюсь на доклад Lea Verou с HolyJS:

[![Lea Verou — JS UX: Writing code for humans](https://i.ytimg.com/vi/gweY3L0YA1Y/hqdefault.jpg)](https://www.youtube.com/watch?v=gweY3L0YA1Y)

ЖС, ну почему ты такой?

### "JS не для тупых"
Так говорит мой коллега. Соглашусь. Он для каких-то гениев, которые компилируют код в голове, проверяют типизацию и нестыковки с компилятором(например, число и типы аргументов конструктора класса-наследника, привет, Closure Compiler[если они не совпадают, то компиль пропустит]).

Почему я должен делать работу компилятора? Мне по всей иерархии пробираться и проверять? На кой нужен компиль, которому нельзя доверять? Окей, у моего любимого C++ тоже есть такие проблемы, но там кейсы скорее синтетические, чем реальные, но у кого-то встречаются. В этом плане Rust поприятнее - согласен. Почему нельзя сделать такую простую вещь, как проверку типов аргументов конструктора класса, унаследованного от другого? Есть задачи поважнее? Если да, то какие, а то видимо я про какой-то трешак не знаю - хотелось бы знать заранее, где ещё что-то "молча ___не__ работает_".

Почему я должен задумываться о каких-то там деоптимизациях и прочей фигне? Либо так писать можно, либо так писать нельзя - третьего не дано. А не "так писать можно и так тоже можно, но в рантайме это деоптимизнётся, а вот так вот ну уж точно нельзя".

### "От одного раза ничего не будет..."
"...ты просто попробуй, тебе понравится!". Откуда эта тяга навязать JS каждому? Когда я захочу добавить интерактивчика на сайт, я обязательно вам об этом скажу, куда вы на backend и desktop полезли? Скорость разработки выше? Допустим, но ровно до тех пор, пока разработчики не начнут наступать на раставленные языком грабли и пока нет нужды в специфичных вещах, которые никому в голову не приходило реализовывать на JS, потому что он медленный как не знай что и с кучей ограничений.

Чтобы не быть голословным - я обожаю работу с графикой, но не такими view'шками как панели, формы и им подобные, а сетки треугольников, прошедшие через пару-тройку шейдеров, - чему там равен `GL_MAX_TEXTURE_IMAGE_UNITS`? По данным [webglstats.com][webglstats], на сей день для WebGL 1 это 8(100%) и 16 (98.8%). Так и быть, 32 в 0.6% случаев, хорошо.

WebGL 1 уже история? Не вопрос - WebGL 2 - 16(100%), 18 и 32 по 8.6%

Тут такое дело...На моём ноутбуке с nVidia 840M на борту и OpenGL 4.6, что уже не говорит о дикой мощи в 2к18, следующие строки кода скажут...
```cpp
GLint bla; // Я пищу на JS, мне так можно
glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &bla);
std::cout << "GL_MAX_TEXTURE_IMAGE_UNITS: " << bla << std::endl;
```
...скажут 32.

Лучше б конструкции вида `null + true - false`(что есть единица) ограничили, а не это вот всё...

### Мечты
JS на свалку, даёшь Python. Кстати о питоне. Появился в 1991. А ЖС в 1995. Вопрос: кто ж это в прошлом так налажал, что вместо развития одного адекватного языка решили за 10 дней склепать другой? Да за 10 дней комьюнити питонистов и каркас браузера развернёт, и поддержку питона в нём вточит. Я, конечно, преувиличиваю, но в 1995 что-то точно пошло не так.
 
Если автор статьи не ошибается, а за 4 года существования статьи часть его "предсказаний" сбылась и никакая не опроверглась...кто возьмётся прикинуть дату, когда о JS начнут вспоминать и слышать, как о Perl в 2018?
 
P.S. Какахи вида "автор сам 1998 года выпуска" можно высказать лично

### _Mr. @PerlPower_
Ой неспроста я не вставил ссылку в предыдущее упоминание об [`@PerlPower`][PerlPower], т.к. в его профиле сказано не воспринимать всерьёз его слова об ИТ, однако кто не поленится - у него есть ещё статьи на тематику ИТ, которые проплюсованы. Так себе аргумент, согласен. Тогда так - из его ника и статей можно сделать вывод о его причастности к Perl, что уже даёт право вполне законно ссылаться на его мнение, которое я и разделил. 

[js-fractal]:    https://habr.com/post/215777
[webglstats]:    https://webglstats.com
[PerlPower]:     https://habr.com/users/PerlPower
